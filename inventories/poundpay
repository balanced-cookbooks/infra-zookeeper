#!/usr/bin/env python
from __future__ import unicode_literals

import json
import os

from confu import aws, ansible
import boto


region = os.environ.get('AWS_REGION', 'us-east-1')
asg_conn = boto.connect_autoscale()
ec2_conn = boto.connect_ec2()

aws.cxn.activate(profile_name='poundpay', default_region=region)

inventory = ansible.AWSRemoteInventory(
    instances=(
        aws.instances()
            .regions(region)
            .filter(('tag:confu:infra-silo', 'zookeeper'))
            .filter(('instance-state-name', 'running'))
    ),
    group_tags=[
        'aws:cloudformation:stack-name',
        'confu:infra-silo',
        ('confu:infra-env', 'env-{value}', 'infra_env'),
        ('confu:roles', lambda value: value.split(','))
    ],
)


def get_zk_asgs():
    groups = asg_conn.get_all_groups()
    for group in groups:
        for tag in group.tags:
            if tag.key == 'confu:infra-silo' and tag.value == 'zookeeper':
                yield group


def get_instance_indices():
    """
    Returns all zk instances sorted by launch time and instance ID.
    This should mean that whenever you add a new ZK instance to this cluster
    it will get a unique ID that always increases.

    TODO: what happens if an instance is terminated? it will change the ID of
    the instances in the cluster.
    """
    groups = set(get_zk_asgs())
    instance_ids = [
        instance.instance_id
        for group in groups
        for instance in group.instances
    ]
    reservations = ec2_conn.get_all_instances(instance_ids)
    sortable = [
        (instance.id, instance.launch_time, instance.private_ip_address)
        for reservation in reservations
        for instance in reservation.instances
    ]
    sorted_instances = sorted(sortable, key=lambda key: (key[1], key[0]))
    for index, (_, _, ip_address) in enumerate(sorted_instances):
        yield ip_address, {'myid': index + 1}


if __name__ == '__main__':
    result = inventory.all()
    result['_meta']['hostvars'].update(dict(get_instance_indices()))
    print json.dumps(result, indent=4, sort_keys=True)
